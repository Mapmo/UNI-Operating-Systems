Скриптът започва с поредица от валидаци, като присвоявам имената на аргументите на променливи с по-ясни имена.

След това проверявам за повтарящи се имена на пулсове, понеже не получих ясен отговор какво да правя ако има такива, то просто съобщавам за съществуването им.

След това преобразувам началото на .xml файла в seconds since Epoch и взимам продължителността, която преобразувам в секунди.

След това исках да направя същото и с .wav файла, като тук ми се наложи да използвам soxi, която инсталирах чрез sudo apt install sox. След като знаех началото на .wav since Epoch ( от beep импулса ), изчислих колко след началото на .xml започва. Така успях да постигна връзка между тях и да намеря колко общо е сечението им, като за целта намерих кое започва по-късно и кое свършва по-рано.

После изваждам честотата на тиковете от .xml файла.

След това създавам временен файл, който има за цел да съхрани всички тикове от .xml файла. Причината за това е, че .xml файлът е доста голям и пренасянето на информацията за тиковете е много тежка операция. Съхранението в променлива също не помага, защото трябва да предавам информацията и чрез поток. Разликата между променлива и временен файл в моя код е от порядъка на 4 минути.

След като притежавам необходимата информация за обработка на .log файла, се заемам точно с това.

Първо валидирам, че интервалът е по-голям от 0.2 секунди и че е в рамките както на .xml, така и на .wav файловете.

Също така създавам променливи xmlRelative, които целят да се определи от коя до коя секунда на .xml файла се случва даденият импулс. Чрез тях създавам променливи xml{Start,End}Line, които са нещото, за което отделих най-много време в домашното. Идеята ми е следната:

xmlStartLine е кой ред от тиковете е първият от импулса. Намирам го като умножавам по честотата въпросната относителна минута, като извършвам ceil закръгляне. За да постигна, ceil закръгляне деля произведението на 1, като ако въпросната секунда се дели с точност на честотата добавям 1, а ако не се дели - 2. Причината за добавянето на 1 е, че броенето на редовете започва от 1, а не от 0.
xmlEndLine е аналогично, като тук целя закръглянето да е floor, което е по-подразбиране в bc.
Причината за тези закръгляния е, че когато умножа по честота, виждам в кой интервал се очаква да е въпросната секунда, като ако е начална, то тя трябва да е в най-близкия по-голям тик ( или в същия ако се дели с точност на честотата), а ако е крайна, то тя трябва да е в по-малкия ( или същия ).

След като имам начален и краен ред, просто ги изваждам със sed от временния файл.

При обработката на .wav използвам sox, като единствено се нуждая от относително начало на аудиото спрямо пулса, тъй като вече съм изчислил дължината на интервала. 

След това изтривам времнния файл и предавам домашното с надеждата проверяващият да е благосклонен. :)

Програмата излиза със следните кодове:
0 - успех
1 - неправилен брой аргументи
2 - невалидна дестинация
3 - невалиден аудио файл
4 - невалиден .xml файл
5 - невалиден .log файл
